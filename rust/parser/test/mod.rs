/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

use crate::{parse_query, parse_query_from};

mod aggregate;
mod autogenerated;
mod builder;
mod builtin_functions;
mod disjunctions;
mod error;
mod fetch;
mod functions;
mod group;
mod group_aggregate;
mod list;
mod match_queries;
mod modifiers;
mod nonquery;
mod pipeline;
mod regex;
mod schema_queries;
mod sugar;
mod write_queries;

macro_rules! assert_valid_eq_repr {
    ($expected:ident, $parsed:ident, $query:ident) => {
        let parsed = $parsed;
        // let expected = $expected;
        let query = $query;
        // assert_eq!(format!("{:#}", expected), query, "\n{expected:#}\n\n{query}\n");
        assert_eq!(format!("{:#}", parsed), query, "\n{parsed:#}\n\n{query}\n");
        // assert_eq!(parsed, expected.into());
    };
}
use assert_valid_eq_repr;

// #[test]
// fn when_parsing_date_error_when_handling_overly_precise_nanos() {
//     let validated = typeql_match!(var("x").has((
//         "release-date",
//         NaiveDateTime::new(
//             NaiveDate::from_ymd_opt(1000, 11, 12).unwrap(),
//             NaiveTime::from_hms_nano_opt(13, 14, 15, 123450000).unwrap(),
//         ),
//     )))
//     ;
//     assert!(validated.is_err());
//     assert!(validated.unwrap_err().to_string().contains("more precise than 1 millisecond"));
// }

// #[test]
// fn test_parsing_without_var_concept() {
//     let query = r#"match
// $_ isa person;"#;
//     let parsed = parse_query(query);
//     assert!(parsed.is_err());
//     let built = typeql_match!(var(()).isa("person"));
//     assert!(built.is_err());
// }

#[test]
fn test_parsing_query_prefix() {
    let input = r#"
    define
      entity person;
    match
    "#;
    let (_query, remainder_index) = parse_query_from(input).unwrap();
    assert!(&input[remainder_index..].trim().starts_with("match"));

    let input = r#"
    define
      entity person;
    end;
    "#;
    let (_query, remainder_index) = parse_query_from(input).unwrap();
    assert!(&input[remainder_index..].trim().is_empty());

    let input = r#"
define

# --- Common properties ---
attribute id, value string; # an inline comment
attribute type, value string;

# TODO:  testing containing comments and newlines...

# --- Properties listed by multiple objects ---

attribute description, value string;

# TODO: struct types
"#;
    let (_query, remainder_index) = parse_query_from(input).unwrap();
    assert!(&input[remainder_index..].trim().is_empty());
}

#[test]
fn test_escape_string() {
    let input = r#"This has \"double quotes\" and a single-quoted backslash: '\\'"#;
    let query = format!(
        r#"insert
$_ isa movie,
    has title "{input}";"#
    );
    let parsed = parse_query(&query).unwrap();
    //     let expected = typeql_insert!(var(()).isa("movie").has(("title", input)));
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn when_parsing_query_with_comments_they_are_ignored() {
    let query = r#"match
# there's a comment here
$x isa###WOW HERES ANOTHER###
movie; reduce $c1 = count($x);"#;
    let uncommented = r#"match
$x isa movie;
reduce $c1 = count($x);"#;
    let parsed = parse_query(query).unwrap();
    // let expected = typeql_match!(var("x").isa("movie")).count();
    assert_valid_eq_repr!(expected, parsed, uncommented);
}
