/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

use crate::{parse_query, parse_query_from};

mod aggregate;
mod autogenerated;
mod builder;
mod builtin_functions;
mod disjunctions;
mod error;
mod fetch;
mod functions;
mod group;
mod group_aggregate;
mod list;
mod match_queries;
mod modifiers;
mod nonquery;
mod regex;
mod schema_queries;
mod sugar;
mod write_queries;

macro_rules! assert_valid_eq_repr {
    ($expected:ident, $parsed:ident, $query:ident) => {
        let parsed = $parsed;
        // let expected = $expected;
        let query = $query;
        // assert_eq!(format!("{:#}", expected), query, "\n{expected:#}\n\n{query}\n");
        assert_eq!(format!("{:#}", parsed), query, "\n{parsed:#}\n\n{query}\n");
        // assert_eq!(parsed, expected.into());
    };
}
use assert_valid_eq_repr;

// #[test]
fn tmp() {
    let query_string = r#"
    define
       name sub attribute, value string @regex("^(foo|bar)$") @values("foo", "bar");
       person sub entity;
       person owns name[] @card(0, *);
    "#;
    let result = parse_query(query_string);
    eprintln!("{result:#?}");
    eprintln!("{:#}", result.unwrap());
    panic!();

    // let query_fn = r#"
    // define
    // fun test_stream_1($x: person) -> {name}:
    //   match
    //    $x isa person, has name $name;
    //   return {$x};

    // fun test_stream_many($x: person) -> {name, age, dob}:
    //   match
    //     $x isa person, has name $name, has age $age, has dob $dob;
    //   select $name, $age, $dob;
    //   sort $name;
    //   offset 10;
    //   limit 10;
    //   return { $name, $age, $dob };

    // fun test_single_1($x: person) -> integer:
    //   match
    //     $x isa person;
    //   return count($x);

    // fun test_single_many($x: person) -> integer, integer:
    //   match
    //     $x isa person, has age $a;
    //   return count($x), sum($a);

    // fun test_stream_optional($x: person) -> { name, age?, dob }:
    //   match
    //     $x isa person, has name $name;
    //     try { $x has age $age; };
    //     $y in get_all_dob($x);
    //   return { $x, $age, $y };

    // fun test_single_optional($x: person) -> name?, integer, double?:
    //   match
    //     $x isa person, has age $age;
    //     try { $one_name = get_a_name($x); };
    //   return $one_name, count($x), std($age);
    //  "#;
    // let result = TypeQLParser::parse(Rule::eof_query, query_fn);
    // dbg!("{}", &result);

    // let query_list_card = r#"
    // match
    // $x is $y;

    // $x > $y;
    // $x like "abc";
    // $x like $y;
    // $x == $y;

    // $x = $y;
    // $x = 10 + 11;

    // person sub attribute @abstract,
    //   value integer @values(1,2,3);

    // $person sub attribute @abstract;
    // $person sub $parent, value string @regex("abc");

    // $person type person;

    // $x sub entity,
    //     owns age as abstract_age @card(0,*) @key @unique,
    //     owns name[] @card(0, *) @distinct,
    //     owns $attr[];

    // $x sub relation,
    //     relates friend @card(10, 100) @cascade,
    //     relates best-friend[] @distinct,
    //     relates $role[];
    // get;
    // "#;
    // let result = TypeQLParser::parse(Rule::eof_query, query_list_card);
    // dbg!("{}", &result);
}

// #[test]
// fn when_parsing_date_error_when_handling_overly_precise_nanos() {
//     let validated = typeql_match!(var("x").has((
//         "release-date",
//         NaiveDateTime::new(
//             NaiveDate::from_ymd_opt(1000, 11, 12).unwrap(),
//             NaiveTime::from_hms_nano_opt(13, 14, 15, 123450000).unwrap(),
//         ),
//     )))
//     ;
//     assert!(validated.is_err());
//     assert!(validated.unwrap_err().to_string().contains("more precise than 1 millisecond"));
// }

// #[test]
// fn test_parsing_without_var_concept() {
//     let query = r#"match
// $_ isa person;"#;
//     let parsed = parse_query(query);
//     assert!(parsed.is_err());
//     let built = typeql_match!(var(()).isa("person"));
//     assert!(built.is_err());
// }

#[test]
fn test_parsing_query_prefix() {
    let input = r#"
    define
      entity person;
    match
    "#;
    let (_query, remainder_index) = parse_query_from(input).unwrap();
    assert!(&input[remainder_index..].trim().starts_with("match"))
}

#[test]
fn test_escape_string() {
    let input = r#"This has \"double quotes\" and a single-quoted backslash: '\\'"#;
    let query = format!(
        r#"insert
$_ isa movie,
    has title "{input}";"#
    );
    let parsed = parse_query(&query).unwrap();
    //     let expected = typeql_insert!(var(()).isa("movie").has(("title", input)));
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn when_parsing_query_with_comments_they_are_ignored() {
    let query = r#"match
# there's a comment here
$x isa###WOW HERES ANOTHER###
movie; reduce $c1 = count($x);"#;
    let uncommented = r#"match
$x isa movie;
reduce $c1 = count($x);"#;
    let parsed = parse_query(query).unwrap();
    // let expected = typeql_match!(var("x").isa("movie")).count();
    assert_valid_eq_repr!(expected, parsed, uncommented);
}
