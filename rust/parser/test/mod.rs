/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

mod autogenerated;
mod builder;
mod builtin_functions;
mod disjunctions;
mod error;
mod group_aggregate;
mod list;
mod match_queries;
mod modifiers;
mod nonquery;
mod regex;
mod schema_queries;

use crate::parse_query;

macro_rules! assert_valid_eq_repr {
    ($expected:ident, $parsed:ident, $query:ident) => {
        let parsed = $parsed;
        // let expected = $expected;
        let query = $query;
        // assert_eq!(format!("{:#}", expected), query, "\n{expected:#}\n\n{query}\n");
        assert_eq!(format!("{:#}", parsed), query, "\n{parsed:#}\n\n{query}\n");
        // assert_eq!(parsed, expected.into());
    };
}
use assert_valid_eq_repr;

// #[test]
fn tmp() {
    let query_string = r#"
    define
       name sub attribute, value string @regex("^(foo|bar)$") @values("foo", "bar");
       person sub entity;
       person owns name[] @card(0, *);
    "#;
    let result = parse_query(query_string);
    eprintln!("{result:#?}");
    eprintln!("{:#}", result.unwrap());
    panic!();

    // let query_fn = r#"
    // define
    // fun test_stream_1($x: person) -> {name}:
    //   match
    //    $x isa person, has name $name;
    //   return {$x};

    // fun test_stream_many($x: person) -> {name, age, dob}:
    //   match
    //     $x isa person, has name $name, has age $age, has dob $dob;
    //   filter $name, $age, $dob;
    //   sort $name;
    //   offset 10;
    //   limit 10;
    //   return { $name, $age, $dob };

    // fun test_single_1($x: person) -> long:
    //   match
    //     $x isa person;
    //   return count($x);

    // fun test_single_many($x: person) -> long, long:
    //   match
    //     $x isa person, has age $a;
    //   return count($x), sum($a);

    // fun test_stream_optional($x: person) -> { name, age?, dob }:
    //   match
    //     $x isa person, has name $name;
    //     try { $x has age $age; };
    //     $y in get_all_dob($x);
    //   return { $x, $age, $y };

    // fun test_single_optional($x: person) -> name?, long, double?:
    //   match
    //     $x isa person, has age $age;
    //     try { $one_name = get_a_name($x); };
    //   return $one_name, count($x), std($age);
    //  "#;
    // let result = TypeQLParser::parse(Rule::eof_query, query_fn);
    // dbg!("{}", &result);

    // let query_list_card = r#"
    // match
    // $x is $y;

    // $x > $y;
    // $x like "abc";
    // $x like $y;
    // $x == $y;

    // $x = $y;
    // $x = 10 + 11;

    // person sub attribute @abstract,
    //   value long @values(1,2,3);

    // $person sub attribute @abstract;
    // $person sub $parent, value string @regex("abc");

    // $person type person;

    // $x sub entity,
    //     owns age as abstract_age @card(0,*) @key @unique,
    //     owns name[] @card(0, *) @distinct,
    //     owns $attr[];

    // $x sub relation,
    //     relates friend @card(10, 100) @cascade,
    //     relates best-friend[] @distinct,
    //     relates $role[];
    // get;
    // "#;
    // let result = TypeQLParser::parse(Rule::eof_query, query_list_card);
    // dbg!("{}", &result);
}

// #[test]
// fn when_parsing_date_error_when_handling_overly_precise_nanos() {
//     let validated = typeql_match!(var("x").has((
//         "release-date",
//         NaiveDateTime::new(
//             NaiveDate::from_ymd_opt(1000, 11, 12).unwrap(),
//             NaiveTime::from_hms_nano_opt(13, 14, 15, 123450000).unwrap(),
//         ),
//     )))
//     ;
//     assert!(validated.is_err());
//     assert!(validated.unwrap_err().to_string().contains("more precise than 1 millisecond"));
// }

// #[test]
// fn test_builder_precedence_operators() {
//     let query = r#"match
// $a = ($b + $c) * $d;"#;

//     let parsed = parse_query(query).unwrap();
//     let expected = typeql_match!(var("a").assign(cvar("b").add(cvar("c")).multiply(cvar("d"))));
//     assert_valid_eq_repr!(expected, parsed, query);
// }

// #[test]
// fn test_builder_associativity_left() {
//     let query = r#"match
// $a = $b - ($c - $d);"#;

//     let parsed = parse_query(query).unwrap();
//     let expected = typeql_match!(var("a").assign(cvar("b").subtract(cvar("c").subtract(cvar("d")))));
//     assert_valid_eq_repr!(expected, parsed, query);
// }

// #[test]
// fn test_builder_associativity_right() {
//     let query = r#"match
// $a = ($b ^ $c) ^ $d;"#;

//     let parsed = parse_query(query).unwrap();
//     let expected = typeql_match!(var("a").assign(cvar("b").power(cvar("c")).power(cvar("d"))));
//     assert_valid_eq_repr!(expected, parsed, query);
// }

// #[test]
// fn test_parenthesis_preserving() {
//     let query = r#"match
// $a = $b + ($c + $d) + $e * ($f * $g);"#;

//     let parsed = parse_query(query).unwrap();
//     let expected = typeql_match!(var("a")
//         .assign(var("b").add(cvar("c").add(cvar("d"))).add(cvar("e").multiply(cvar("f").multiply(cvar("g"))))))
//     ;
//     assert_valid_eq_repr!(expected, parsed, query);
// }

// #[test]
// fn test_parenthesis_not_adding_unnecessary() {
//     let query = r#"match
// $a = $b + $c + $d + $e * $f * $g;"#;

//     let parsed = parse_query(query).unwrap();
//     let expected = typeql_match!(var("a")
//         .assign(var("b").add(cvar("c")).add(cvar("d")).add(cvar("e").multiply(cvar("f")).multiply(cvar("g")))))
//     ;
//     assert_valid_eq_repr!(expected, parsed, query);
// }

#[test]
fn test_fetch_query() {
    let query = r#"match
$x isa movie,
    has title "Godfather",
    has release-date $d;
fetch
$d;
$d as date;
$x: name, title as t, name as "Movie name";
$x as movie: name;
$x as "Movie name": name;
label-a: {
    match
    ($d, $c) isa director;
    fetch
    $d: name, age;
};
label-b: {
    match
    ($d, $c) isa director;
    filter $d;
    count();
};"#;
    let parsed = parse_query(query).unwrap();
    // let projections: Vec<Projection> = vec![
    // var("d").into(),
    // var("d").label("date").into(),
    // var("x").map_attributes(vec!["name".into(), ("title", "t").into(), ("name", "Movie name").into()]),
    // var("x").label("movie").map_attribute("name"),
    // var("x").label("Movie name").map_attribute("name"),
    // label("label-a").map_subquery_fetch(
    // typeql_match!(rel(var("d")).links(cvar("c")).isa("director"))
    // .fetch(vec![var("d").map_attributes(vec!["name".into(), "age".into()])]),
    // ),
    // label("label-b").map_subquery_get_aggregate(
    // typeql_match!(rel(var("d")).links(cvar("c")).isa("director")).get_fixed([cvar("d")]).count(),
    // ),
    // ];
    // let expected = typeql_match!(var("x").isa("movie").has(("title", "Godfather")).has(("release-date", cvar("d"))))
    // .fetch(projections);
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn test_variables_everywhere_query() {
    let query = r#"match
($p: $x, $y);
$x isa $z;
$y == "crime";
$z sub production;
has-genre relates $p;"#;
    let parsed = parse_query(query).unwrap();
    // let expected = typeql_match!(
    // rel((var("p"), cvar("x"))).links("y"),
    // var("x").isa(cvar("z")),
    // var("y").eq("crime"),
    // var("z").sub("production"),
    // type_("has-genre").relates(var("p")),
    // );
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn test_parsing_relates_type_variable() {
    let query = r#"match
$x isa $type;
$type relates someRole;"#;
    let parsed = parse_query(query).unwrap();
    // let expected = typeql_match!(var("x").isa(cvar("type")), cvar("type").relates("someRole"));
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn test_aggregate_count_query() {
    let query = r#"match
($x, $y) isa friendship;
filter $x, $y;
count($x);"#;
    let parsed = parse_query(query).unwrap();
    //     let expected = typeql_match!(rel("x").links("y").isa("friendship")).get_fixed([var("x"), cvar("y")]).count();
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn when_comparing_count_query_using_typeql_and_rust_typeql_they_are_equivalent() {
    let query = r#"match
$x isa movie,
    has title "Godfather";
count();"#;
    let parsed = parse_query(query).unwrap();
//     let expected = typeql_match!(var("x").isa("movie").has(("title", "Godfather"))).count();
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn test_delete_query() {
    let query = r#"match
$x isa movie,
    has title "The Title";
$y isa movie,
    has title $t;
delete
$x;
has $t of $y;"#;
    let parsed = parse_query(query).unwrap();
    //     let expected = typeql_match!(var("x").isa("movie").has(("title", "The Title")), cvar("y").isa("movie"))
    //         .delete([var("x").isa("movie"), cvar("y").isa("movie")]);
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn test_insert_query() {
    let query = r#"insert
$x isa pokemon,
    has name "Pichu";
$y isa pokemon,
    has name "Pikachu";
$z isa pokemon,
    has name "Raichu";
(evolves-from: $x, evolves-to: $y) isa evolution;
(evolves-from: $y, evolves-to: $z) isa evolution;"#;
    let parsed = parse_query(query).unwrap();
    //     let expected = typeql_insert!(
    //         var("x").isa("pokemon").has(("name", "Pichu")),
    //         var("y").isa("pokemon").has(("name", "Pikachu")),
    //         var("z").isa("pokemon").has(("name", "Raichu")),
    //         rel(("evolves-from", "x")).links(("evolves-to", "y")).isa("evolution"),
    //         rel(("evolves-from", "y")).links(("evolves-to", "z")).isa("evolution")
    //     );
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn test_update_query() {
    let query = r#"match
$x isa person,
    has name "alice",
    has age $a;
update
$x has age 25;"#;
    let parsed = parse_query(query).unwrap();
    //     let expected = typeql_match!(var("x").isa("person").has(("name", "alice")).has(("age", cvar("a"))))
    //         .delete(var("x").has(cvar("a")))
    //         .insert(var("x").has(("age", 25)));
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn when_parsing_as_in_define_result_is_same_as_sub() {
    let query = r#"define
parent sub role;
child sub role;
parenthood sub relation,
    relates parent,
    relates child;
fatherhood sub parenthood,
    relates father as parent,
    relates son as child;"#;
    let parsed = parse_query(query).unwrap();
    //     let expected = typeql_define!(
    //         type_("parent").sub("role"),
    //         type_("child").sub("role"),
    //         type_("parenthood").sub("relation").relates("parent").relates("child"),
    //         type_("fatherhood").sub("parenthood").relates(("father", "parent")).relates(("son", "child"))
    //     );
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn when_parsing_as_in_match_result_is_same_as_sub() {
    let query = r#"match
$f sub parenthood,
    relates father as parent,
    relates son as child;"#;
    let parsed = parse_query(query).unwrap();
    //     let expected =
    //         typeql_match!(var("f").sub("parenthood").relates(("father", "parent")).relates(("son", "child")));
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn test_match_insert_query() {
    let query = r#"match
$x isa language;
insert
$x has name "HELLO";"#;
    let parsed = parse_query(query).unwrap();
    //     let expected = typeql_match!(var("x").isa("language")).insert(cvar("x").has(("name", "HELLO")));
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn test_match_value_type_query() {
    let query = r#"match
$x value double;"#;
    let parsed = parse_query(query).unwrap();
    //     let expected = typeql_match!(var("x").value(ValueType::Double));
    assert_valid_eq_repr!(expected, parsed, query);
}

// #[test]
// fn test_parsing_without_var_concept() {
//     let query = r#"match
// $_ isa person;"#;
//     let parsed = parse_query(query);
//     assert!(parsed.is_err());
//     let built = typeql_match!(var(()).isa("person"));
//     assert!(built.is_err());
// }

#[test]
fn when_parsing_date_keyword_parse_as_the_correct_value_type() {
    let query = r#"match
$x value datetime;"#;
    let parsed = parse_query(query).unwrap();
    //     let expected = typeql_match!(var("x").value(ValueType::DateTime));
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn test_escape_string() {
    let input = r#"This has \"double quotes\" and a single-quoted backslash: '\\'"#;
    let query = format!(
        r#"insert
$_ isa movie,
    has title "{input}";"#
    );
    let parsed = parse_query(&query).unwrap();
    //     let expected = typeql_insert!(var(()).isa("movie").has(("title", input)));
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn when_parsing_query_with_comments_they_are_ignored() {
    let query = r#"match
# there's a comment here
$x isa###WOW HERES ANOTHER###
movie; count();"#;
    let uncommented = r#"match
$x isa movie;
count();"#;
    let parsed = parse_query(query).unwrap();
    // let expected = typeql_match!(var("x").isa("movie")).count();
    assert_valid_eq_repr!(expected, parsed, uncommented);
}

#[test]
fn test_parsing_boolean() {
    let query = r#"insert
$_ has flag true;"#;
    let parsed = parse_query(query).unwrap();
    //     let expected = typeql_insert!(var(()).has(("flag", true)));
    assert_valid_eq_repr!(expected, parsed, query);
}

// #[test]
// fn test_parsing_aggregate_group() {
//     let query = r#"match
// $x isa movie;
// group $x;"#;
//     let parsed = parse_query(query).unwrap().into_get_group();
//     let expected = typeql_match!(var("x").isa("movie")).group(cvar("x"));
//     assert_valid_eq_repr!(expected, parsed, query);
// }

// #[test]
// fn test_parsing_aggregate_group_count() {
//     let query = r#"match
// $x isa movie;
// group $x; count;"#;
//     let parsed = parse_query(query).unwrap().into_get_group_aggregate();
//     let expected = typeql_match!(var("x").isa("movie")).group(cvar("x")).count();
//     assert_valid_eq_repr!(expected, parsed, query);
// }

#[test]
fn test_parsing_aggregate_std() {
    let query = r#"match
$x isa movie;
std($x);"#;
    let parsed = parse_query(query).unwrap();
    // let expected = typeql_match!(var("x").isa("movie")).std(cvar("x"));
    assert_valid_eq_repr!(expected, parsed, query);
}

// #[test]
// fn test_parsing_aggregate_to_string() {
//     let query = r#"match
// $x isa movie;
// get $x;
// group $x; count;"#;
//     assert_eq!(query, parse_query(query).unwrap().to_string());
// }

#[test]
fn test_has_variable() {
    let query = r#"match
$_ has title "Godfather",
    has tmdb-vote-count $x;"#;
    let parsed = parse_query(query).unwrap();
    //     let expected = typeql_match!(var(()).has(("title", "Godfather")).has(("tmdb-vote-count", cvar("x"))));
    assert_valid_eq_repr!(expected, parsed, query);
}

#[test]
fn test_regex_attribute_type() {
    let query = r#"match
$x value string @regex("(fe)male");"#;
    let parsed = parse_query(query).unwrap();
    // let expected = typeql_match!(var("x").regex("(fe)male"));
    assert_valid_eq_repr!(expected, parsed, query);
}
