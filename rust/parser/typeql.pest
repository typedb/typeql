/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

eof_query = { SOI ~ query ~ EOI }
eof_queries = { SOI ~ query+ ~ EOI }
eof_pattern = { SOI ~ pattern ~ EOI }
eof_patterns = { SOI ~ patterns ~ EOI }
eof_definables = { SOI ~ definables ~ EOI }
eof_statement = { SOI ~ statement ~ EOI }
eof_label = { SOI ~ label ~ EOI }
eof_definition_function = { SOI ~ definition_function ~ EOI }

// TYPEQL QUERY LANGUAGE =======================================================

query = { query_schema | query_data }

query_schema = { query_define | query_undefine }
query_define = { DEFINE ~ definables }
query_undefine = { UNDEFINE ~ definables }

query_data = { query_stage+ }
query_stage = { stage_match
              | stage_insert
              | stage_delete
              | stage_put
              | stage_fetch
              | stage_reduce
              | stage_modifier
              }

// query_get_group_agg = { query_get ~ clause_group ~ stage_reduce }
// query_get_group = { query_get ~ clause_group }
// query_get_aggregate = { query_get ~ stage_reduce }
// query_get = { stage_match ~ clause_get ~ stage_modifier* }
// clause_group = { GROUP ~ var ~ SEMICOLON } // TODO: eliminate?

stage_match = { MATCH ~ patterns }
stage_insert = { INSERT ~ statement_things }
stage_delete = { DELETE ~ statement_things }
stage_put = { PUT ~ statement_things }
stage_fetch = { FETCH ~ projections }
stage_reduce = { reduce ~ SEMICOLON }
reduce = { reduce_limited
         | reduce_all ~ ( COMMA ~ reduce_all )* }
reduce_limited = { CHECK | reduce_first }
reduce_first = { FIRST ~ PAREN_OPEN ~ var ~ ( COMMA ~ var )* ~ PAREN_CLOSE }
reduce_all = { COUNT ~ PAREN_OPEN ~ var? ~ ( COMMA ~ var )* ~ PAREN_CLOSE
             | MAX ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             | MIN ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             | MEAN ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             | MEDIAN ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             | STD ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             | SUM ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             }

// QUERY MODIFIERS =============================================================

stage_modifier = { stage_filter ~ SEMICOLON | stage_sort ~ SEMICOLON | stage_offset ~ SEMICOLON | stage_limit ~ SEMICOLON }

stage_filter = { FILTER ~ var ~ ( COMMA ~ var )* }
stage_sort = { SORT ~ var_order ~ ( COMMA ~ var_order )* }
stage_offset = { OFFSET ~ long_value }
stage_limit = { LIMIT ~ long_value }

var_order = { var ~ ORDER? }

// FETCH QUERY =================================================================

projections = { ( projection ~ SEMICOLON )+ }
projection = { projection_key_var ~ COLON ~ projection_attributes
             | projection_key_var
             | projection_key_label ~ COLON ~ CURLY_OPEN ~ projection_subquery ~ CURLY_CLOSE }

projection_attributes = { projection_attribute ~ ( COMMA ~ projection_attribute )* }
projection_attribute = { label ~ projection_key_as_label? }

// TODO: we have to validate this is a fetch or reduce ended pipeline
projection_subquery = { query_data }

projection_key_var = { var ~ projection_key_as_label? }
projection_key_as_label = { AS ~ projection_key_label }
projection_key_label = { quoted_string | label }

// SCHEMA QUERY ================================================================

definables = { definable+ }
definable = { ( definition_type ~ SEMICOLON )
            // | definition_function
            // | definition_struct
            }

// QUERY PATTERNS ==============================================================

patterns = { ( pattern ~ SEMICOLON )+ }
pattern = { statement | pattern_disjunction | pattern_conjunction | pattern_negation | pattern_try }

pattern_conjunction = { CURLY_OPEN ~ patterns ~ CURLY_CLOSE }
pattern_disjunction = { CURLY_OPEN ~ patterns ~ CURLY_CLOSE ~ ( OR ~ CURLY_OPEN ~ patterns ~ CURLY_CLOSE )+ }
pattern_negation = { NOT ~ CURLY_OPEN ~ patterns ~ CURLY_CLOSE }
pattern_try = { TRY ~ CURLY_OPEN ~ patterns ~ CURLY_CLOSE }

// STATEMENTS ==================================================================

statement = { statement_type | statement_thing_var | statement_single | statement_anon_relation }

// SINGLE STATEMENTS ===========================================================

statement_single = { statement_is | statement_comparison | statement_assignment | statement_in }

statement_is = { var ~ IS ~ var }
statement_comparison = { expression_value ~ comparison }
statement_assignment = { assignment_left ~ ASSIGN ~ expression }
assignment_left = { var ~ ( COMMA ~ var )* | struct_destructor }
statement_in = { var ~ ( COMMA ~ var )* ~ IN ~ expression_function }

// TYPE STATEMENTS =============================================================

statement_type = { type_ref_any ~ type_constraint ~ ( COMMA ~ type_constraint )* }
type_constraint = { sub_constraint
                  | value_type_constraint
                  | label_constraint
                  | owns_constraint
                  | relates_constraint
                  | plays_constraint
                  }

sub_constraint = { SUB_ ~ type_ref_any ~ annotations_sub }
value_type_constraint = { VALUE ~ value_type_primitive ~ annotations_value }
label_constraint = { TYPE ~ label_any }
owns_constraint = { OWNS ~ type_ref_list ~ annotations_owns
                  | OWNS ~ type_ref ~ ( AS ~ type_ref )? ~ annotations_owns
                  }
relates_constraint = { RELATES ~ type_ref_list ~ annotations_relates
                     | RELATES ~ type_ref ~ ( AS ~ type_ref )? ~ annotations_relates
                     }
plays_constraint = { PLAYS ~ type_ref_scoped ~ ( AS ~ type_ref )? }

annotations_sub = { ( ANNOTATION_ABSTRACT | ANNOTATION_CASCADE | ANNOTATION_INDEPENDENT )* }
annotations_owns = { ( annotation_card | ANNOTATION_DISTINCT | ANNOTATION_KEY | ANNOTATION_UNIQUE )* }
annotations_relates = { ( annotation_card | ANNOTATION_DISTINCT | ANNOTATION_CASCADE )* } // ( ANNOTATION_ABSTRACT )?
annotations_value = { ( annotation_regex | annotation_values )* }

annotation_card = { ANNOTATION_CARD ~ PAREN_OPEN ~ annotation_card_lower ~ COMMA ~ annotation_card_upper ~ PAREN_CLOSE }
annotation_regex = { ANNOTATION_REGEX ~ PAREN_OPEN ~ quoted_string ~ PAREN_CLOSE }
annotation_subkey = { ANNOTATION_SUBKEY ~ PAREN_OPEN ~ label ~ PAREN_CLOSE }
annotation_values = { ANNOTATION_VALUES ~ PAREN_OPEN ~ value_primitive ~ ( COMMA ~ value_primitive )* ~ PAREN_CLOSE }

// THING STATEMENTS ============================================================

statement_things = { ( statement_thing ~ SEMICOLON )+ }
statement_thing = { statement_thing_var | statement_anon_relation }
statement_anon_relation = { relation ~ ( COMMA ~ thing_constraint )* }

statement_thing_var = { var ~ thing_constraint ~ ( COMMA ~ thing_constraint )*
                      | var ~ ( value_primitive | expression_struct ) ~ isa_constraint
                      | var ~ comparison ~ isa_constraint
                      }

thing_constraint = { isa_constraint
                   | iid_constraint
                   | has_constraint
                   | links_constraint
                   }

isa_constraint = { ISA_ ~ type_ref }
iid_constraint = { IID ~ iid_value }
has_constraint = { HAS ~ type_ref_list ~ ( comparison | expression_list | var )
                 | HAS ~ type_ref ~ ( comparison | expression_value )
                 | HAS ~ var
                 }
links_constraint = { LINKS ~ relation }

relation = { PAREN_OPEN ~ role_player ~ ( COMMA ~ role_player )* ~ PAREN_CLOSE } // A list of role players in a Relations
role_player = { type_ref_list ~ COLON ~ var
              | type_ref ~ COLON ~ var
              | var
              }

// COMPARISON CONSTRUCTS =======================================================

comparison = { comparator ~ expression_value }
comparator = { EQ | NEQ | GTE | GT | LTE | LT | CONTAINS | LIKE }

// EXPRESSION CONSTRUCTS =======================================================

expression = { expression_list | expression_value }

expression_value = { expression_base ~ ( expression_operator ~ expression_base )* }
expression_base = _{ expression_list_index | expression_parenthesis | expression_function | value_primitive | var }

expression_operator = _{ POWER | MULTIPLY | DIVIDE | MODULO | ADD | SUBTRACT }
expression_parenthesis = { PAREN_OPEN ~ expression_value ~ PAREN_CLOSE }

expression_list_index = { var ~ list_index }
list_index = { SQ_BRACKET_OPEN ~ expression_value ~ SQ_BRACKET_CLOSE }

expression_function = { expression_function_name ~ PAREN_OPEN ~ expression_arguments? ~ PAREN_CLOSE }
expression_function_name = { builtin_func_name | label }
expression_arguments = { expression ~ ( COMMA ~ expression )* }

expression_list = { expression_list_subrange | expression_list_new }
expression_list_new = { SQ_BRACKET_OPEN ~ expression_value ~ ( COMMA ~ expression_value )* ~ SQ_BRACKET_CLOSE }
expression_list_subrange = { var ~ list_range }
list_range = { SQ_BRACKET_OPEN ~ expression_value ~ COLON ~ expression_value ~ SQ_BRACKET_CLOSE }

expression_struct = { CURLY_OPEN ~ struct_key ~ COLON ~ struct_value ~ CURLY_CLOSE }
struct_value = { expression_value | expression_struct }

// TYPE DEFINITION =============================================================

definition_type = { label ~ type_constraint_declaration ~ ( COMMA ~ type_constraint_declaration )* }
type_constraint_declaration = { sub_declaration
                              | value_type_declaration
                              | owns_declaration
                              | relates_declaration
                              | plays_declaration
                              }

sub_declaration = { SUB ~ label ~ annotations_sub }
value_type_declaration = { VALUE ~ ( value_type_primitive ~ annotations_value | label ) }
owns_declaration = { OWNS ~ list_label ~ annotations_owns
                   | OWNS ~ label ~ ( AS ~ label )? ~ annotations_owns
                   }
relates_declaration = { RELATES ~ list_label ~ annotations_relates
                      | RELATES ~ label ~ ( AS ~ label )? ~ annotations_relates
                      }
plays_declaration = { PLAYS ~ label_scoped ~ ( AS ~ label )? }

// FUNCTION DEFINITION =========================================================

definition_function = { FUN ~ function_signature ~ COLON ~ stage_match ~ stage_modifier* ~ return_statement }

function_signature = { label ~ PAREN_OPEN ~ function_arguments ~ PAREN_CLOSE ~ ARROW ~ function_return }

function_arguments = { ( function_argument ~ ( COMMA ~ function_argument ) * )? }
function_argument = { var ~ COLON ~ label }

function_return = { function_return_stream | function_return_single }
function_return_stream = { CURLY_OPEN ~ function_return_value ~ ( "," ~ function_return_value )* ~ CURLY_CLOSE }
function_return_single = { function_return_value ~ ( "," ~ function_return_value )* }
function_return_value = { function_return_value_optional | function_return_value_base }
function_return_value_optional = { function_return_value_base ~ QUESTION }
function_return_value_base = { list_value_type_primitive | value_type_primitive | list_label | label }

return_statement = { RETURN ~ ( return_statement_stream | return_statement_single ) ~ SEMICOLON }
return_statement_stream = { CURLY_OPEN ~ var ~ ( COMMA ~ var )* ~ CURLY_CLOSE }
return_statement_single = { ( var | reduce ) ~ ( COMMA ~ ( var | reduce ) )* }

// STRUCT CONSTRUCTS ===========================================================

definition_struct = { STRUCT ~ label ~ COLON ~ definition_struct_fields ~ SEMICOLON }
definition_struct_fields = { definition_struct_field ~ ( COMMA ~ definition_struct_field )* }
definition_struct_field = { struct_key ~ VALUE ~ ( value_type_primitive | label ) }

struct_destructor = { CURLY_OPEN ~ struct_key ~ COLON ~ struct_destructor_value }
struct_destructor_value = { var | struct_destructor }

struct_key = { label }

// TYPE, label AND IDENTIFIER CONSTRUCTS =======================================

type_ref_any = { type_ref_scoped | type_ref }
type_ref_scoped = { label_scoped | var }
type_ref = { label | var }
type_ref_list = { list_label | list_var }

label_any = { label_scoped | label }
list_label = { label ~ SQ_BRACKET_OPEN ~ SQ_BRACKET_CLOSE }

// LITERAL INPUT VALUES ========================================================

type_native = { ENTITY | ATTRIBUTE | RELATION | ROLE }

value_type_primitive = { LONG | DOUBLE | STRING | BOOLEAN | DATETIME }
list_value_type_primitive = { value_type_primitive ~ SQ_BRACKET_OPEN ~ SQ_BRACKET_CLOSE }

value_primitive = { quoted_string | datetime_value | date_value | boolean_value
                  | signed_double | signed_long
                  }

signed_double = { sign? ~ double_value }
signed_long = { sign? ~ long_value }
sign = { ADD | SUBTRACT }

// UNRESERVED KEYWORDS =========================================================
// Most of TypeQL syntax should not be reserved from being used as identifiers

// TODO: this doesn't mean anything in a PEG but we probably need a reserved list instead
unreserved = { VALUE | FILTER | SORT | LIMIT | OFFSET | GROUP | LIKE | CONTAINS }

// TYPEQL SYNTAX KEYWORDS ======================================================

// QUERY COMMAND KEYWORDS

MATCH = @{ "match" ~ WB }
FETCH = @{ "fetch" ~ WB }
DEFINE = @{ "define" ~ WB }
UNDEFINE = @{ "undefine" ~ WB }
INSERT = @{ "insert" ~ WB }
PUT = @{ "put" ~ WB }
DELETE = @{ "delete" ~ WB }
CHECK = @{ "check" ~ WB }
FIRST = @{ "first" ~ WB }

// NATIVE TYPE KEYWORDS

ENTITY = @{ "entity" ~ WB }
ATTRIBUTE = @{ "attribute" ~ WB }
RELATION = @{ "relation" ~ WB }
ROLE = @{ "role" ~ WB }

// DELETE AND GET QUERY MODIFIER KEYWORDS

FILTER = @{ "filter" ~ WB }
LIMIT = @{ "limit" ~ WB }
OFFSET = @{ "offset" ~ WB }
SORT = @{ "sort" ~ WB }
ORDER = ${ ASC | DESC }
ASC = @{ "asc" ~ WB }
DESC = @{ "desc" ~ WB }

// FUNCTION KEYWORDS

FUN = @{ "fun" ~ WB }
RETURN = @{ "return" ~ WB }

// TYPE VARIABLE CONSTRAINT KEYWORDS

TYPE = @{ "type" ~ WB }
SUB_ = ${ SUBX | SUB }
SUB = @{ "sub" ~ WB }
SUBX = @{ "sub!" ~ WB }
OWNS = @{ "owns" ~ WB }
AS = @{ "as" ~ WB }
PLAYS = @{ "plays" ~ WB }
RELATES = @{ "relates" ~ WB }

// TYPE ANNOTATIONS

// unparametrized
ANNOTATION_ABSTRACT = @{ "@abstract" ~ WB }
ANNOTATION_CASCADE = @{ "@cascade" ~ WB }
ANNOTATION_DISTINCT = @{ "@distinct" ~ WB }
ANNOTATION_KEY = @{ "@key" ~ WB }
ANNOTATION_INDEPENDENT = @{ "@independent" ~ WB }
ANNOTATION_UNIQUE = @{ "@unique" ~ WB }

// parametrized
ANNOTATION_CARD = @{ "@card" ~ WB }
ANNOTATION_RANGE = @{ "@range" ~ WB }
ANNOTATION_REGEX = @{ "@regex" ~ WB }
ANNOTATION_SUBKEY = @{ "@subkey" ~ WB }
ANNOTATION_VALUES = @{ "@values" ~ WB }

annotation_card_lower = @{ ASCII_DIGIT+ }
annotation_card_upper = @{ ASCII_DIGIT+ | "*" }

// THING VARIABLE CONSTRAINT KEYWORDS

IID = @{ "iid" ~ WB }
ISA_ = ${ ISAX | ISA }
ISA = @{ "isa" ~ WB }
ISAX = @{ "isa!" ~ WB }
LINKS = @{ "links" ~ WB }
HAS = @{ "has" ~ WB }
VALUE = @{ "value" ~ WB }
IS = @{ "is" ~ WB }

// PATTERN KEYWORDS

OR = @{ "or" ~ WB }
NOT = @{ "not" ~ WB }
TRY = @{ "try" ~ WB }

// COMPARATOR KEYWORDS

EQ = @{ "==" }
NEQ = @{ "!=" }
GT = @{ ">" }
GTE = @{ ">=" }
LT = @{ "<" }
LTE = @{ "<=" }
LIKE = @{ "like" ~ WB }
CONTAINS = @{ "contains" ~ WB }

// ASSIGNMENT AND EXPRESSION KEYWORDS

ASSIGN = @{ "=" }
IN = @{ "in" }

ADD = @{ "+" }
SUBTRACT = @{ "-" }
DIVIDE = @{ "/" }
MULTIPLY = @{ "*" }
POWER = @{ "^" }
MODULO = @{ "%" }

// Incomplete list of function names usable in expressions. The 'expression_function_name' rule references all function names.
builtin_func_name = ${ ABS | CEIL | FLOOR | ROUND | LENGTH | MAX | MIN }
ABS = @{ "abs" ~ WB }
CEIL = @{ "ceil" ~ WB }
FLOOR = @{ "floor" ~ WB }
ROUND = @{ "round" ~ WB }
LENGTH = @{ "length" ~ WB }

// GROUP AND AGGREGATE QUERY KEYWORDS (also used by COMPUTE QUERY)

GROUP = @{ "group" ~ WB }
COUNT = @{ "count" ~ WB }
MAX = @{ "max" ~ WB }
MIN = @{ "min" ~ WB }
MEAN = @{ "mean" ~ WB }
MEDIAN = @{ "median" ~ WB }
STD = @{ "std" ~ WB }
SUM = @{ "sum" ~ WB }

// VALUE TYPE KEYWORDS

LONG = @{ "long" ~ WB }
DOUBLE = @{ "double" ~ WB }
STRING = @{ "string" ~ WB }
BOOLEAN = @{ "boolean" ~ WB }
DATETIME = @{ "datetime" ~ WB }
STRUCT = @{ "struct" ~ WB }

// LITERAL VALUE KEYWORDS
boolean_value = ${ TRUE | FALSE } // order of lexer declaration matters
TRUE = @{ "true" ~ WB }
FALSE = @{ "false" ~ WB }
quoted_string = @{ "\"" ~ ( !"\"" ~ !"\\" ~ ANY | escape_seq )* ~ "\""
                 | "'" ~ ( !"'" ~ !"\\" ~ ANY | escape_seq )* ~ "'" }
long_value = @{ ASCII_DIGIT+ ~ WB }
double_value = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ WB }
date_value = ${ date_fragment ~ WB }
datetime_value = ${ date_fragment ~ "T" ~ time ~ WB }

// TYPEQL INPUT PATTERNS
var = ${ VAR_ANONYMOUS | var_named }
VAR_ANONYMOUS = @{ "$_" ~ WB }
var_named = @{ "$" ~ IDENTIFIER_VAR_H ~ IDENTIFIER_VAR_T* ~ WB }
list_var = @{ var ~ SQ_BRACKET_OPEN ~ SQ_BRACKET_CLOSE }
iid_value = @{ "0x" ~ ASCII_HEX_DIGIT+ ~ WB }
label = @{ IDENTIFIER_LABEL_H ~ IDENTIFIER_LABEL_T* ~ WB }
label_scoped = ${ label ~ ":" ~ label ~ WB }

// PUNCTUATION =================================================================

PAREN_OPEN = _{ "(" }
PAREN_CLOSE = _{ ")" }
SQ_BRACKET_OPEN = _{ "[" }
SQ_BRACKET_CLOSE = _{ "]" }
CURLY_OPEN = _{ "{" }
CURLY_CLOSE = _{ "}" }
COMMA = _{ "," }
SEMICOLON = _{ ";" }
COLON = _{ ":" }
QUESTION = _{ "?" }
ARROW = _{ "->" }

// FRAGMENTS OF KEYWORDS =======================================================

IDENTIFIER_CHAR = @{ ASCII_ALPHA
                   | '\u{00C0}'..'\u{00D6}'
                   | '\u{00D8}'..'\u{00F6}'
                   | '\u{00F8}'..'\u{02FF}'
                   | '\u{0370}'..'\u{037D}'
                   | '\u{037F}'..'\u{1FFF}'
                   | '\u{200C}'..'\u{200D}'
                   | '\u{2070}'..'\u{218F}'
                   | '\u{2C00}'..'\u{2FEF}'
                   | '\u{3001}'..'\u{D7FF}'
                   | '\u{F900}'..'\u{FDCF}'
                   | '\u{FDF0}'..'\u{FFFD}'
                   }
IDENTIFIER_CONNECTOR = @{ "_"
                        | "-"
                        | "\u{00B7}"
                        | '\u{0300}'..'\u{036F}'
                        | '\u{203F}'..'\u{2040}'
                        }

IDENTIFIER_LABEL_H = @{ IDENTIFIER_CHAR }
IDENTIFIER_LABEL_T = @{ IDENTIFIER_LABEL_H | ASCII_DIGIT | IDENTIFIER_CONNECTOR }

IDENTIFIER_VAR_H = @{ IDENTIFIER_CHAR | ASCII_DIGIT }
IDENTIFIER_VAR_T = @{ IDENTIFIER_VAR_H | IDENTIFIER_CONNECTOR }

date_fragment = ${ year ~ "-" ~ month ~ "-" ~ day }
month = @{ "0" ~ ( '1'..'9' ) | "10" | "11" | "12" }
day = @{ ( '0'..'3' ) ~ ASCII_DIGIT }
year = @{ ASCII_DIGIT{4} | ( "+" | "-" ) ~ ASCII_DIGIT+ }
time = ${ hour ~ COLON ~ minute ~ ( COLON ~ second ~ ( "." ~ second_fraction )? )? }
hour = @{ ( '0'..'2' ) ~ ASCII_DIGIT }
minute = @{ ( '0'..'6' ) ~ ASCII_DIGIT }
second = @{ ( '0'..'6' ) ~ ASCII_DIGIT }
second_fraction = @{ ASCII_DIGIT{1,9} } // between 1 and 9 digits
escape_seq = @{ "\\" ~ ANY }

WB = _{ &( PUNCTUATION | WHITESPACE | COMMENT | EOI ) } // Word boundary

COMMENT = _{ "#" ~ ( !NEWLINE ~ ANY )* ~ ( NEWLINE | EOI ) }
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
