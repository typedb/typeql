/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

eof_query = { SOI ~ query ~ EOI }
eof_queries = { SOI ~ query+ ~ EOI }
eof_pattern = { SOI ~ pattern ~ EOI }
eof_patterns = { SOI ~ patterns ~ EOI }
eof_definables = { SOI ~ definables ~ EOI }
eof_statement = { SOI ~ statement ~ EOI }
eof_label = { SOI ~ label ~ EOI }
eof_definition_function = { SOI ~ definition_function ~ EOI }

// TYPEQL QUERY LANGUAGE =======================================================

query = { query_schema | query_data }

query_schema = { query_define | query_undefine }
query_define = { DEFINE ~ definables }
query_undefine = { UNDEFINE ~ definables }

query_data = { query_stage+ }
query_stage = { stage_match
              | stage_insert
              | stage_delete
              | stage_put
              | stage_fetch
              | stage_reduce
              | stage_modifier
              }

// query_get_group_agg = { query_get ~ clause_group ~ stage_reduce }
// query_get_group = { query_get ~ clause_group }
// query_get_aggregate = { query_get ~ stage_reduce }
// query_get = { stage_match ~ clause_get ~ stage_modifier* }
// clause_group = { GROUP ~ VAR ~ SEMICOLON } // TODO: eliminate?

stage_match = { MATCH ~ patterns }
stage_insert = { INSERT ~ statement_things }
stage_delete = { DELETE ~ statement_things }
stage_put = { DELETE ~ statement_things }
stage_fetch = { FETCH ~ projections }
stage_reduce = { reduce ~ SEMICOLON }
reduce = { reduce_limited
         | reduce_all ~ ( COMMA ~ reduce_all )* }
reduce_all = { COUNT ~ PAREN_OPEN ~ VAR? ~ ( COMMA ~ VAR )* ~ PAREN_CLOSE
             | MAX ~ PAREN_OPEN ~ VAR ~ PAREN_CLOSE
             | MEAN ~ PAREN_OPEN ~ VAR ~ PAREN_CLOSE
             | MEDIAN ~ PAREN_OPEN ~ VAR ~ PAREN_CLOSE
             | MIN ~ PAREN_OPEN ~ VAR ~ PAREN_CLOSE
             | STD ~ PAREN_OPEN ~ VAR ~ PAREN_CLOSE
             | SUM ~ PAREN_OPEN ~ VAR ~ PAREN_CLOSE
             }
reduce_limited = { CHECK | reduce_first }
reduce_first = { FIRST ~ VAR ~ ( COMMA ~ VAR )* }

// QUERY MODIFIERS =============================================================

stage_modifier = { stage_filter ~ SEMICOLON | stage_sort ~ SEMICOLON | offset ~ SEMICOLON | stage_limit ~ SEMICOLON }
stage_filter = { FILTER ~ VAR ~ ( COMMA ~ VAR )* }
stage_limit = { LIMIT ~ LONG_VALUE }
stage_sort = { SORT ~ var_order ~ ( COMMA ~ var_order )* }
var_order = { VAR ~ ORDER_? }
offset = { OFFSET ~ LONG_VALUE }

// FETCH QUERY =================================================================

projections = { ( projection ~ SEMICOLON )+ }
projection = { projection_key_var ~ COLON ~ projection_attributes
             | projection_key_var
             | projection_key_label ~ COLON ~ CURLY_OPEN ~ projection_subquery ~ CURLY_CLOSE }

projection_attributes = { projection_attribute ~ ( COMMA ~ projection_attribute )* }
projection_attribute = { label ~ projection_key_as_label? }

// TODO: we have to validate this is a fetch or reduce ended pipeline
projection_subquery = { query_data }

projection_key_var = { VAR ~ projection_key_as_label? }
projection_key_as_label = { AS ~ projection_key_label }
projection_key_label = { QUOTED_STRING | label }

// SCHEMA QUERY ================================================================

definables = { definable+ }
definable = { ( definition_type ~ SEMICOLON ) 
            // | definition_function
            // | definition_struct
            }

// QUERY PATTERNS ==============================================================

patterns = { ( pattern ~ SEMICOLON )+ }
pattern = { statement | pattern_disjunction | pattern_conjunction | pattern_negation | pattern_try }

pattern_conjunction = { CURLY_OPEN ~ patterns ~ CURLY_CLOSE }
pattern_disjunction = { CURLY_OPEN ~ patterns ~ CURLY_CLOSE ~ ( OR ~ CURLY_OPEN ~ patterns ~ CURLY_CLOSE )+ }
pattern_negation = { NOT ~ CURLY_OPEN ~ patterns ~ CURLY_CLOSE }
pattern_try = { TRY ~ CURLY_OPEN ~ patterns ~ CURLY_CLOSE }

// STATEMENTS ==================================================================

statement = { statement_single | statement_multi }

// SINGLE STATEMENTS ===========================================================

statement_single = { statement_is | statement_comparison | statement_assignment | statement_in }

statement_is = { VAR ~ IS ~ VAR }
statement_comparison = { expression_value ~ comparison }
statement_assignment = { assignment_left ~ ASSIGN ~ expression_value_or_list }
assignment_left = { VAR ~ ( COMMA ~ VAR )* | struct_destructor }
statement_in = { VAR ~ ( COMMA ~ VAR )* ~ IN ~ expression_function }

// MULTI STATEMENT =============================================================

statement_multi = { statement_type | statement_thing }

// TYPE STATEMENTS =============================================================

statement_type = { type_ref_any ~ type_constraint ~ ( COMMA ~ type_constraint )* }
type_constraint = { SUB_ ~ type_ref_any ~ annotations_sub
                  | VALUE ~ value_type_primitive ~ annotations_value
                  | TYPE ~ label_any
                  | owns_constraint
                  | relates_constraint
                  | plays_constraint
                  }

owns_constraint = { OWNS ~ type_ref_list ~ annotations_owns
                  | OWNS ~ type_ref ~ ( AS ~ type_ref )? ~ annotations_owns
                  }
relates_constraint = { RELATES ~ type_ref_list ~ annotations_relates
                     | RELATES ~ type_ref ~ ( AS ~ type_ref )? ~ annotations_relates
                     }
plays_constraint = { PLAYS ~ type_ref_scoped ~ ( AS ~ type_ref )? }

annotations_sub = { ( ANNOTATION_ABSTRACT | ANNOTATION_CASCADE | ANNOTATION_INDEPENDENT )* }
annotations_owns = { ( annotation_card | ANNOTATION_DISTINCT | ANNOTATION_KEY | ANNOTATION_UNIQUE )* }
annotations_relates = { ( annotation_card | ANNOTATION_DISTINCT | ANNOTATION_CASCADE )* } // ( ANNOTATION_ABSTRACT )?
annotations_value = { ( annotation_regex | annotation_values )* }

annotation_card = { ANNOTATION_CARD ~ PAREN_OPEN ~ ANNOTATION_CARD_LOWER ~ COMMA ~ ANNOTATION_CARD_UPPER ~ PAREN_CLOSE }
annotation_regex = { ANNOTATION_REGEX ~ PAREN_OPEN ~ QUOTED_STRING ~ PAREN_CLOSE }
annotation_subkey = { ANNOTATION_SUBKEY ~ PAREN_OPEN ~ label ~ PAREN_CLOSE }
annotation_values = { ANNOTATION_VALUES ~ PAREN_OPEN ~ value_primitive ~ ( COMMA ~ value_primitive )* ~ PAREN_CLOSE }

// THING STATEMENTS ============================================================

statement_things = { ( statement_thing ~ SEMICOLON )+ }
statement_thing = { thing_start ~ ( COMMA ~ thing_constraint )* }

thing_start = { relation
              | VAR ~ thing_constraint
              | VAR ~ value_primitive ~ ISA_ ~ type_ref
              | VAR ~ expression_struct ~ ISA_ ~ type_ref
              | VAR ~ comparison ~ ISA_ ~ type_ref
              }

thing_constraint = { ISA_ ~ type_ref
                   | IID ~ IID_VALUE
                   | relates_constraint
                   | has_constraint
                   }

has_constraint = { HAS ~ ( VAR | label ~ ( expression_value | comparison ) )
                 | HAS ~ type_ref_list ~ ( expression_list | comparison )
                 }
relation_constraint = { LINKS ~ relation }

relation = { PAREN_OPEN ~ role_player ~ ( COMMA ~ role_player )* ~ PAREN_CLOSE } // A list of role players in a Relations
role_player = { type_ref_list ~ COLON ~ VAR
              | type_ref ~ COLON ~ VAR
              | VAR
              }

// COMPARISON CONSTRUCTS =======================================================

comparison = { comparator ~ expression_value }
comparator = { EQ | NEQ | GTE | GT | LTE | LT | CONTAINS | LIKE }

// EXPRESSION CONSTRUCTS =======================================================

expression_value_or_list = { expression_value | expression_list }

expression_value = { expression_base ~ ( expression_operator ~ expression_base )* }
expression_base = _{ VAR | value_primitive | expression_function | expression_parenthesis | expression_list_index }

expression_operator = _{ POWER | MULTIPLY | DIVIDE | MODULO | ADD | SUBTRACT }
expression_parenthesis = { PAREN_OPEN ~ expression_value ~ PAREN_CLOSE }

expression_list_index = { VAR ~ list_index }
list_index = { SQ_BRACKET_OPEN ~ expression_value ~ SQ_BRACKET_CLOSE }

expression_function = { expression_function_name ~ PAREN_OPEN ~ expression_arguments? ~ PAREN_CLOSE }
expression_function_name = { EXPR_FUNC_NAME | MAX | MIN | label }
expression_arguments = { expression_value ~ ( COMMA ~ expression_value )* }

expression_list = { VAR | expression_list_new | expression_list_subrange }
expression_list_new = { SQ_BRACKET_OPEN ~ expression_value ~ ( COMMA ~ expression_value )* ~ SQ_BRACKET_CLOSE }
expression_list_subrange = { VAR ~ list_range }
list_range = { SQ_BRACKET_OPEN ~ expression_value ~ COLON ~ expression_value ~ SQ_BRACKET_CLOSE }

expression_struct = { CURLY_OPEN ~ struct_key ~ COLON ~ struct_value ~ CURLY_CLOSE }
struct_value = { expression_value | expression_struct }

// TYPE DEFINITION =============================================================

definition_type = { label ~ type_constraint_declaration ~ ( COMMA ~ type_constraint_declaration )* }
type_constraint_declaration = { sub_declaration
                              | value_type_declaration
                              | owns_declaration
                              | relates_declaration
                              | plays_declaration
                              }

sub_declaration = { SUB ~ label ~ annotations_sub }
value_type_declaration = { VALUE ~ ( value_type_primitive ~ annotations_value | label ) }
owns_declaration = { OWNS ~ list_label ~ annotations_owns
                   | OWNS ~ label ~ ( AS ~ label )? ~ annotations_owns
                   }
relates_declaration = { RELATES ~ list_label ~ annotations_relates
                      | RELATES ~ label ~ ( AS ~ label )? ~ annotations_relates
                      }
plays_declaration = { PLAYS ~ label_scoped ~ ( AS ~ label )? }

// FUNCTION DEFINITION =========================================================

definition_function = { FUN ~ function_signature ~ COLON ~ stage_match ~ stage_modifier* ~ return_statement }

function_signature = { label ~ PAREN_OPEN ~ function_arguments ~ PAREN_CLOSE ~ ARROW ~ function_return }

function_arguments = { ( function_argument ~ ( COMMA ~ function_argument ) * )? }
function_argument = { VAR ~ COLON ~ label }

function_return = { function_return_stream | function_return_single }
function_return_stream = { CURLY_OPEN ~ function_return_value ~ ( "," ~ function_return_value )* ~ CURLY_CLOSE }
function_return_single = { function_return_value ~ ( "," ~ function_return_value )* }
function_return_value = { function_return_value_optional | function_return_value_base }
function_return_value_optional = { function_return_value_base ~ QUESTION }
function_return_value_base = { list_value_type_primitive | value_type_primitive | list_label | label }

return_statement = { RETURN ~ ( return_statement_stream | return_statement_single ) ~ SEMICOLON }
return_statement_stream = { CURLY_OPEN ~ VAR ~ ( COMMA ~ VAR )* ~ CURLY_CLOSE }
return_statement_single = { ( VAR | reduce ) ~ ( COMMA ~ ( VAR | reduce ) )* }

// STRUCT CONSTRUCTS ===========================================================

definition_struct = { STRUCT ~ label ~ COLON ~ definition_struct_fields ~ SEMICOLON }
definition_struct_fields = { definition_struct_field ~ ( COMMA ~ definition_struct_field )* }
definition_struct_field = { struct_key ~ VALUE ~ ( value_type_primitive | label ) }

struct_destructor = { CURLY_OPEN ~ struct_key ~ COLON ~ struct_destructor_value }
struct_destructor_value = { VAR | struct_destructor }

struct_key = { label }

// TYPE, LABEL AND IDENTIFIER CONSTRUCTS =======================================

type_ref_any = { type_ref_scoped | type_ref | VAR }
type_ref_scoped = { label_scoped | VAR }
type_ref = { label | VAR }
type_ref_list = { list_label | LIST_VAR }

label_any = { label_scoped | label }
label_scoped = { LABEL_SCOPED }
label = { LABEL | type_native | unreserved }
list_label = { LABEL ~ SQ_BRACKET_OPEN ~ SQ_BRACKET_CLOSE }

// LITERAL INPUT VALUES ========================================================

type_native = { ENTITY | ATTRIBUTE | RELATION | ROLE }

value_type_primitive = { LONG | DOUBLE | STRING | BOOLEAN | DATETIME }
list_value_type_primitive = { value_type_primitive ~ SQ_BRACKET_OPEN ~ SQ_BRACKET_CLOSE }

value_primitive = { QUOTED_STRING | DATETIME_VALUE | DATE_VALUE | BOOLEAN_
                  | signed_double | signed_long
                  }

signed_double = { sign? ~ DOUBLE_VALUE }
signed_long = { sign? ~ LONG_VALUE }
sign = { ADD | SUBTRACT }

// UNRESERVED KEYWORDS =========================================================
// Most of TypeQL syntax should not be reserved from being used as identifiers

unreserved = { VALUE | FILTER | SORT | LIMIT | OFFSET | GROUP | LIKE | CONTAINS }

// TYPEQL SYNTAX KEYWORDS ======================================================

// QUERY COMMAND KEYWORDS

MATCH = @{ "match" ~ WB }
FETCH = @{ "fetch" ~ WB }
DEFINE = @{ "define" ~ WB }
UNDEFINE = @{ "undefine" ~ WB }
INSERT = @{ "insert" ~ WB }
DELETE = @{ "delete" ~ WB }
CHECK = @{ "check" }
FIRST = @{ "first" ~ WB }

// NATIVE TYPE KEYWORDS

ENTITY = @{ "entity" ~ WB }
ATTRIBUTE = @{ "attribute" ~ WB }
RELATION = @{ "relation" ~ WB }
ROLE = @{ "role" ~ WB }

// DELETE AND GET QUERY MODIFIER KEYWORDS

FILTER = @{ "filter" ~ WB }
LIMIT = @{ "limit" ~ WB }
OFFSET = @{ "offset" ~ WB }
SORT = @{ "sort" ~ WB }
ORDER_ = @{ ASC | DESC }
ASC = @{ "asc" ~ WB }
DESC = @{ "desc" ~ WB }

// FUNCTION KEYWORDS

FUN = @{ "fun" ~ WB }
RETURN = @{ "return" ~ WB }

// TYPE VARIABLE CONSTRAINT KEYWORDS

TYPE = @{ "type" ~ WB }
SUB_ = ${ SUBX | SUB }
SUB = @{ "sub" ~ WB }
SUBX = @{ "sub!" ~ WB }
OWNS = @{ "owns" ~ WB }
AS = @{ "as" ~ WB }
PLAYS = @{ "plays" ~ WB }
RELATES = @{ "relates" ~ WB }

// TYPE ANNOTATIONS

// unparametrized
ANNOTATION_ABSTRACT = @{ "@abstract" ~ WB }
ANNOTATION_CASCADE = @{ "@cascade" ~ WB }
ANNOTATION_DISTINCT = @{ "@distinct" ~ WB }
ANNOTATION_KEY = @{ "@key" ~ WB }
ANNOTATION_INDEPENDENT = @{ "@independent" ~ WB }
ANNOTATION_UNIQUE = @{ "@unique" ~ WB }

// parametrized
ANNOTATION_CARD = @{ "@card" }
ANNOTATION_RANGE = @{ "@range" }
ANNOTATION_REGEX = @{ "@regex" }
ANNOTATION_SUBKEY = @{ "@subkey" }
ANNOTATION_VALUES = @{ "@values" }

ANNOTATION_CARD_LOWER = @{ ASCII_DIGIT+ }
ANNOTATION_CARD_UPPER = @{ ASCII_DIGIT+ | "*" }

// THING VARIABLE CONSTRAINT KEYWORDS

IID = @{ "iid" ~ WB }
ISA_ = ${ ISAX | ISA }
ISA = @{ "isa" ~ WB }
ISAX = @{ "isa!" ~ WB }
LINKS = @{ "links" ~ WB }
HAS = @{ "has" ~ WB }
VALUE = @{ "value" ~ WB }
IS = @{ "is" ~ WB }

// PATTERN KEYWORDS

OR = @{ "or" ~ WB }
NOT = @{ "not" ~ WB }
TRY = @{ "try" ~ WB }

// COMPARATOR KEYWORDS

EQ = @{ "==" }
NEQ = @{ "!=" }
GT = @{ ">" }
GTE = @{ ">=" }
LT = @{ "<" }
LTE = @{ "<=" }
LIKE = @{ "like" ~ WB }
CONTAINS = @{ "contains" ~ WB }

// ASSIGNMENT AND EXPRESSION KEYWORDS

ASSIGN = @{ "=" }
IN = @{ "in" }

ADD = @{ "+" }
SUBTRACT = @{ "-" }
DIVIDE = @{ "/" }
MULTIPLY = @{ "*" }
POWER = @{ "^" }
MODULO = @{ "%" }

// Incomplete list of function names usable in expressions. The 'expression_function_name' rule references all function names.
EXPR_FUNC_NAME = _{ ABS | CEIL | FLOOR | ROUND | LENGTH }
ABS = @{ "abs" }
CEIL = @{ "ceil" }
FLOOR = @{ "floor" }
ROUND = @{ "round" }
LENGTH = @{ "length" ~ WB }

// GROUP AND AGGREGATE QUERY KEYWORDS (also used by COMPUTE QUERY)

GROUP = @{ "group" ~ WB }
COUNT = @{ "count" ~ WB }
MAX = @{ "max" ~ WB }
MIN = @{ "min" ~ WB }
MEAN = @{ "mean" ~ WB }
MEDIAN = @{ "median" ~ WB }
STD = @{ "std" ~ WB }
SUM = @{ "sum" ~ WB }

// VALUE TYPE KEYWORDS

LONG = @{ "long" ~ WB }
DOUBLE = @{ "double" ~ WB }
STRING = @{ "string" ~ WB }
BOOLEAN = @{ "boolean" ~ WB }
DATETIME = @{ "datetime" ~ WB }
STRUCT = @{ "struct" ~ WB }

// LITERAL VALUE KEYWORDS
BOOLEAN_ = ${ TRUE | FALSE } // order of lexer declaration matters
TRUE = @{ "true" ~ WB }
FALSE = @{ "false" ~ WB }
QUOTED_STRING = @{ "\"" ~ ( !"\"" ~ !"\\" ~ ANY | ESCAPE_SEQ )* ~ "\""
                 | "'" ~ ( !"'" ~ !"\\" ~ ANY | ESCAPE_SEQ )* ~ "'" }
LONG_VALUE = @{ ASCII_DIGIT+ ~ WB }
DOUBLE_VALUE = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ WB }
DATE_VALUE = ${ DATE_FRAGMENT ~ WB }
DATETIME_VALUE = ${ DATE_FRAGMENT ~ "T" ~ TIME ~ WB }

// TYPEQL INPUT PATTERNS
VAR = ${ VAR_ANONYMOUS | VAR_NAMED }
VAR_ANONYMOUS = @{ "$_" ~ WB }
VAR_NAMED = @{ "$" ~ IDENTIFIER_VAR_H ~ IDENTIFIER_VAR_T* ~ WB }
LIST_VAR = @{ VAR ~ SQ_BRACKET_OPEN ~ SQ_BRACKET_CLOSE }
IID_VALUE = @{ "0x" ~ ASCII_HEX_DIGIT+ ~ WB }
LABEL = @{ IDENTIFIER_LABEL_H ~ IDENTIFIER_LABEL_T* ~ WB }
LABEL_SCOPED = ${ LABEL ~ ":" ~ LABEL ~ WB }

// PUNCTUATION =================================================================

PAREN_OPEN = _{ "(" }
PAREN_CLOSE = _{ ")" }
SQ_BRACKET_OPEN = _{ "[" }
SQ_BRACKET_CLOSE = _{ "]" }
CURLY_OPEN = _{ "{" }
CURLY_CLOSE = _{ "}" }
COMMA = _{ "," }
SEMICOLON = _{ ";" }
COLON = _{ ":" }
QUESTION = _{ "?" }
ARROW = _{ "->" }

// FRAGMENTS OF KEYWORDS =======================================================

IDENTIFIER_CHAR = @{ ASCII_ALPHA
                   | '\u{00C0}'..'\u{00D6}'
                   | '\u{00D8}'..'\u{00F6}'
                   | '\u{00F8}'..'\u{02FF}'
                   | '\u{0370}'..'\u{037D}'
                   | '\u{037F}'..'\u{1FFF}'
                   | '\u{200C}'..'\u{200D}'
                   | '\u{2070}'..'\u{218F}'
                   | '\u{2C00}'..'\u{2FEF}'
                   | '\u{3001}'..'\u{D7FF}'
                   | '\u{F900}'..'\u{FDCF}'
                   | '\u{FDF0}'..'\u{FFFD}'
                   }
IDENTIFIER_CONNECTOR = @{ "_"
                        | "-"
                        | "\u{00B7}"
                        | '\u{0300}'..'\u{036F}'
                        | '\u{203F}'..'\u{2040}'
                        }

IDENTIFIER_LABEL_H = @{ IDENTIFIER_CHAR }
IDENTIFIER_LABEL_T = @{ IDENTIFIER_LABEL_H | ASCII_DIGIT | IDENTIFIER_CONNECTOR }

IDENTIFIER_VAR_H = @{ IDENTIFIER_CHAR | ASCII_DIGIT }
IDENTIFIER_VAR_T = @{ IDENTIFIER_VAR_H | IDENTIFIER_CONNECTOR }

DATE_FRAGMENT = ${ YEAR ~ "-" ~ MONTH ~ "-" ~ DAY }
MONTH = @{ ('0'..'1') ~ ASCII_DIGIT }
DAY = @{ ('0'..'3') ~ ASCII_DIGIT }
YEAR = @{ ASCII_DIGIT{4} | ( "+" | "-" ) ~ ASCII_DIGIT+ }
TIME = ${ HOUR ~ COLON ~ MINUTE ~ ( COLON ~ SECOND ~ ( "." ~ SECOND_FRACTION )? )? }
HOUR = @{ ( '0'..'2' ) ~ ASCII_DIGIT }
MINUTE = @{ ( '0'..'6' ) ~ ASCII_DIGIT }
SECOND = @{ ( '0'..'6' ) ~ ASCII_DIGIT }
SECOND_FRACTION = @{ ASCII_DIGIT{1,3} } // between 1 and 3 digits
ESCAPE_SEQ = @{ "\\" ~ ANY }

WB = _{ &( PUNCTUATION | WHITESPACE | COMMENT | EOI ) } // Word boundary

COMMENT = _{ "#" ~ ( !NEWLINE ~ ANY )* ~ ( NEWLINE | EOI ) }
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
