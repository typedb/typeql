/*
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at https://mozilla.org/MPL/2.0/.
 */

eof_query = { SOI ~ query ~ EOI }
eof_label = { SOI ~ label ~ EOI }
eof_definition_function = { SOI ~ definition_function ~ EOI }
eof_definition_struct = { SOI ~ definition_struct ~ EOI }

// TODO: do we need these?
eof_queries = { SOI ~ query+ ~ EOI }
eof_pattern = { SOI ~ pattern ~ EOI }
eof_patterns = { SOI ~ patterns ~ EOI }
eof_definables = { SOI ~ definables ~ EOI }
// undefinables etc
eof_statement = { SOI ~ statement ~ EOI }

// TYPEQL QUERY LANGUAGE =======================================================

query = { query_schema | query_data }

query_data = { preamble* ~ query_stage+ ~ query_stage_final? }
preamble = { WITH ~ definition_function }
query_stage = { stage_match
              | stage_insert
              | stage_put
              | stage_modifier
              }
query_stage_final = { stage_delete
                    | stage_fetch
                    | stage_reduce
                    }

// query_get_group_agg = { query_get ~ clause_group ~ stage_reduce }
// query_get_group = { query_get ~ clause_group }
// clause_group = { GROUP ~ var ~ SEMICOLON } // TODO: eliminate?

stage_match = { MATCH ~ patterns }
stage_insert = { INSERT ~ statement_things }
stage_delete = { DELETE ~ statement_things }
stage_put = { PUT ~ statement_things }
stage_fetch = { FETCH ~ projections }
stage_reduce = { reduce ~ SEMICOLON }
reduce = { reduce_limited
         | reduce_all ~ ( COMMA ~ reduce_all )* }
reduce_limited = { CHECK | reduce_first }
reduce_first = { FIRST ~ PAREN_OPEN ~ vars ~ PAREN_CLOSE }
reduce_all = { COUNT ~ PAREN_OPEN ~ vars? ~ PAREN_CLOSE
             | MAX ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             | MIN ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             | MEAN ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             | MEDIAN ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             | STD ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             | SUM ~ PAREN_OPEN ~ var ~ PAREN_CLOSE
             }

// QUERY MODIFIERS =============================================================

stage_modifier = { stage_filter ~ SEMICOLON | stage_sort ~ SEMICOLON | stage_offset ~ SEMICOLON | stage_limit ~ SEMICOLON }

stage_filter = { FILTER ~ vars }
stage_sort = { SORT ~ var_order ~ ( COMMA ~ var_order )* }
stage_offset = { OFFSET ~ integer_literal }
stage_limit = { LIMIT ~ integer_literal }

var_order = { var ~ ORDER? }

// QUERY PATTERNS ==============================================================

patterns = { ( pattern ~ SEMICOLON )+ }
pattern = { statement | pattern_disjunction | pattern_conjunction | pattern_negation | pattern_try }

pattern_conjunction = { CURLY_OPEN ~ patterns ~ CURLY_CLOSE }
pattern_disjunction = { CURLY_OPEN ~ patterns ~ CURLY_CLOSE ~ ( OR ~ CURLY_OPEN ~ patterns ~ CURLY_CLOSE )+ }
pattern_negation = { NOT ~ CURLY_OPEN ~ patterns ~ CURLY_CLOSE }
pattern_try = { TRY ~ CURLY_OPEN ~ patterns ~ CURLY_CLOSE }

// FETCH QUERY =================================================================

projections = { ( projection ~ SEMICOLON )+ }
projection = { projection_key_var ~ COLON ~ projection_attributes
             | projection_key_var
             | projection_key_label ~ COLON ~ CURLY_OPEN ~ projection_subquery ~ CURLY_CLOSE
             }

projection_attributes = { projection_attribute ~ ( COMMA ~ projection_attribute )* }
projection_attribute = { label ~ projection_key_as_label? }

// TODO: we have to validate this is a fetch or reduce ended pipeline
projection_subquery = { query_data }

projection_key_var = { var ~ projection_key_as_label? }
projection_key_as_label = { AS ~ projection_key_label }
projection_key_label = { quoted_string_literal | label }

// STATEMENTS ==================================================================

statement = { statement_type | statement_thing_var | statement_single | statement_anon_relation }

// SINGLE STATEMENTS ===========================================================

statement_single = { statement_is | statement_comparison | statement_assignment | statement_in }

statement_is = { var ~ IS ~ var }
statement_comparison = { expression_value ~ comparison }
statement_assignment = { assignment_left ~ ASSIGN ~ expression }
assignment_left = { vars | struct_destructor }
statement_in = { vars ~ IN ~ expression_function }

// TYPE STATEMENTS =============================================================

statement_type = { type_ref_any ~ type_constraint ~ ( COMMA ~ type_constraint )* }
type_constraint = { sub_constraint
                  | value_type_constraint
                  | label_constraint
                  | owns_constraint
                  | relates_constraint
                  | plays_constraint
                  }

sub_constraint = { SUB_ ~ type_ref_any ~ annotations_sub }
value_type_constraint = { VALUE ~ ( value_type_primitive ~ annotations_value | label ) }
label_constraint = { LABEL ~ ( label_scoped | label ) }
owns_constraint = { OWNS ~ type_ref_list ~ annotations_owns
                  | OWNS ~ type_ref ~ ( AS ~ type_ref )? ~ annotations_owns
                  }
relates_constraint = { RELATES ~ type_ref_list ~ annotations_relates
                     | RELATES ~ type_ref ~ ( AS ~ type_ref )? ~ annotations_relates
                     }
plays_constraint = { PLAYS ~ type_ref_scoped ~ ( AS ~ type_ref )? }

// THING STATEMENTS ============================================================

statement_things = { ( statement_thing ~ SEMICOLON )+ }
statement_thing = { statement_thing_var | statement_anon_relation }
statement_anon_relation = { relation ~ ( COMMA ~ thing_constraint )* }

statement_thing_var = { var ~ thing_constraint ~ ( COMMA ~ thing_constraint )*
                      | var ~ ( value_literal | expression_struct ) ~ isa_constraint
                      | var ~ comparison ~ isa_constraint
                      }

thing_constraint = { isa_constraint
                   | iid_constraint
                   | has_constraint
                   | links_constraint
                   }

isa_constraint = { ISA_ ~ type_ref }
iid_constraint = { IID ~ iid_value }
has_constraint = { HAS ~ type_ref_list ~ ( comparison | expression_list | var )
                 | HAS ~ type_ref ~ ( comparison | expression_value )
                 | HAS ~ var
                 }
links_constraint = { LINKS ~ relation }

relation = { PAREN_OPEN ~ role_player ~ ( COMMA ~ role_player )* ~ PAREN_CLOSE } // A list of role players in a Relations
role_player = { type_ref_list ~ COLON ~ var
              | type_ref ~ COLON ~ var
              | var
              }

// COMPARISON CONSTRUCTS =======================================================

comparison = { comparator ~ expression_value }
comparator = { EQ | NEQ | GTE | GT | LTE | LT | CONTAINS | LIKE }

// EXPRESSION CONSTRUCTS =======================================================

expression = { expression_list | expression_value }

expression_value = { expression_base ~ ( expression_operator ~ expression_base )* }
expression_base = _{ expression_list_index | expression_parenthesis | expression_function | value_literal | var }

expression_operator = _{ CARET | ASTERISK | SOLIDUS | PERCENT | PLUS | MINUS }
expression_parenthesis = { PAREN_OPEN ~ expression_value ~ PAREN_CLOSE }

expression_list_index = { var ~ list_index }
list_index = { SQ_BRACKET_OPEN ~ expression_value ~ SQ_BRACKET_CLOSE }

expression_function = { expression_function_name ~ PAREN_OPEN ~ expression_arguments? ~ PAREN_CLOSE }
expression_function_name = { builtin_func_name | identifier }
expression_arguments = { expression ~ ( COMMA ~ expression )* }

expression_list = { expression_list_subrange | expression_list_new }
expression_list_new = { SQ_BRACKET_OPEN ~ expression_value ~ ( COMMA ~ expression_value )* ~ SQ_BRACKET_CLOSE }
expression_list_subrange = { var ~ list_range }
list_range = { SQ_BRACKET_OPEN ~ expression_value ~ COLON ~ expression_value ~ SQ_BRACKET_CLOSE }

expression_struct = { CURLY_OPEN ~ struct_key ~ COLON ~ struct_value ~ CURLY_CLOSE }
struct_value = { expression_value | expression_struct }

// SCHEMA QUERY ================================================================

query_schema = { query_define | query_undefine /* | query_redefine */ }

// DEFINE QUERY ================================================================

query_define = { DEFINE ~ definables }

definables = { definable+ }
definable = { ( definition_type ~ SEMICOLON ) | definition_function | definition_struct }

// TYPE DEFINITION =============================================================

definition_type = { identifier ~ type_capability_declaration ~ ( COMMA ~ type_capability_declaration )* }
type_capability_declaration = { sub_declaration | value_type_declaration | alias_declaration
                              | owns_declaration | plays_declaration | relates_declaration
                              }

sub_declaration = { SUB ~ label ~ annotations_sub }

value_type_declaration = { VALUE ~ ( value_type_primitive ~ annotations_value | label ) }

alias_declaration = { ALIAS ~ label }

owns_declaration = { OWNS ~ list_label ~ annotations_owns
                   | OWNS ~ label ~ ( AS ~ label )? ~ annotations_owns
                   }

plays_declaration = { PLAYS ~ label_scoped ~ ( AS ~ label )? }

relates_declaration = { RELATES ~ list_label ~ annotations_relates
                      | RELATES ~ label ~ ( AS ~ label )? ~ annotations_relates
                      }

// FUNCTION DEFINITION =========================================================

definition_function = { FUN ~ function_signature ~ COLON ~ stage_match ~ stage_modifier* ~ return_statement }

function_signature = { identifier ~ PAREN_OPEN ~ function_arguments ~ PAREN_CLOSE ~ ARROW ~ function_return }

function_arguments = { ( function_argument ~ ( COMMA ~ function_argument )* )? }
function_argument = { var ~ COLON ~ label_arg }

function_return = { function_return_stream | function_return_single }
function_return_stream = { CURLY_OPEN ~ function_return_value ~ ( COMMA ~ function_return_value )* ~ CURLY_CLOSE }
function_return_single = { function_return_value ~ ( COMMA ~ function_return_value )* }
function_return_value = { function_return_value_optional | function_return_value_base }
function_return_value_optional = { function_return_value_base ~ QUESTION }
function_return_value_base = { list_value_type_primitive | value_type_primitive | list_label | label }

return_statement = { RETURN ~ ( return_statement_stream | return_statement_single ) ~ SEMICOLON }
return_statement_stream = { CURLY_OPEN ~ vars ~ CURLY_CLOSE }
return_statement_single = { ( var | reduce ) ~ ( COMMA ~ ( var | reduce ) )* }

// STRUCT DEFINITION ===========================================================

definition_struct = { STRUCT ~ identifier ~ COLON ~ definition_struct_fields ~ SEMICOLON }
definition_struct_fields = { definition_struct_field ~ ( COMMA ~ definition_struct_field )* }
definition_struct_field = { identifier ~ VALUE ~ ( value_type_primitive | label ) }

struct_destructor = { CURLY_OPEN ~ identifier ~ COLON ~ struct_destructor_value }
struct_destructor_value = { var | struct_destructor }

// UNDEFINE QUERY ==============================================================

query_undefine = { UNDEFINE ~ undefinables }

undefinables = { undefinable+ }
undefinable = { ( undefine_from ~ SEMICOLON ) | undefine_function | undefine_struct | label }

undefine_from = { annotation_kind ~ FROM ~ undefine_annotation_recipient
                | AS ~ label ~ FROM ~ undefine_override_recipient
                | type_capability_declaration ~ FROM ~ label
                }
undefine_annotation_recipient = { label ~ VALUE ~ label
                                | label ~ OWNS ~ label
                                | label ~ RELATES ~ label
                                | label ~ PLAYS ~ label_scoped
                                | label
                                }

undefine_override_recipient = { label ~ SUB ~ label
                              | label ~ VALUE ~ label
                              | label ~ OWNS ~ label
                              | label ~ RELATES ~ label
                              | label ~ PLAYS ~ label_scoped
                              | label
                              }

undefine_function = { FUN ~ identifier }
undefine_struct = { STRUCT ~ identifier }

// REDEFINE QUERY ==============================================================

query_redefine = { UNDEFINE ~ redefinables }

redefinables = { redefinable+ }
redefinable = { ( definition_type ~ SEMICOLON )  }  // TODO (reuse definable parts)

// TYPE, LABEL AND IDENTIFIER CONSTRUCTS =======================================

label = ${ kind | identifier }
label_scoped = ${ label ~ COLON ~ label ~ WB }

identifier = @{ !reserved ~ IDENTIFIER_LABEL_H ~ IDENTIFIER_LABEL_T* ~ WB }

type_ref_any = { type_ref_scoped | type_ref }
type_ref_scoped = { label_scoped | var }
type_ref = { label | var }
type_ref_list = { list_label | list_var }

label_arg = { list_label | label }
list_label = { label ~ SQ_BRACKET_OPEN ~ SQ_BRACKET_CLOSE }

struct_key = { identifier }

iid_value = @{ "0x" ~ ASCII_HEX_DIGIT+ ~ WB }

// VARIABLES ===================================================================

vars = { var ~ ( COMMA ~ var )* }

var = ${ VAR_ANONYMOUS | var_named }
VAR_ANONYMOUS = @{ "$_" ~ WB }
var_named = ${ "$" ~ identifier_var }
identifier_var = @{ IDENTIFIER_VAR_H ~ IDENTIFIER_VAR_T* ~ WB }

list_var = ${ var ~ SQ_BRACKET_OPEN ~ SQ_BRACKET_CLOSE }

// LITERAL INPUT VALUES ========================================================

kind = { ENTITY | ATTRIBUTE | RELATION | ROLE }

value_type_primitive = { BOOLEAN | LONG | DOUBLE | DECIMAL
                       | DATETIME_TZ | DATETIME | DATE | DURATION
                       | STRING
                       }
list_value_type_primitive = { value_type_primitive ~ SQ_BRACKET_OPEN ~ SQ_BRACKET_CLOSE }

value_literal = { quoted_string_literal | datetime_literal | date_literal | boolean_literal
                | signed_decimal | signed_integer
                }

signed_decimal = { sign? ~ decimal_literal }
signed_integer = { sign? ~ integer_literal }
sign = { PLUS | MINUS }

// ANNOTATIONS =================================================================

annotations_sub = { ( ANNOTATION_ABSTRACT | ANNOTATION_CASCADE | ANNOTATION_INDEPENDENT )* }
annotations_owns = { ( annotation_card | ANNOTATION_DISTINCT | ANNOTATION_KEY | ANNOTATION_UNIQUE )* }
annotations_relates = { ( annotation_card | ANNOTATION_DISTINCT | ANNOTATION_CASCADE )* } // ( ANNOTATION_ABSTRACT )?
annotations_value = { ( annotation_regex | annotation_values )* }

annotation_card = { ANNOTATION_CARD ~ PAREN_OPEN ~ annotation_card_lower ~ COMMA ~ annotation_card_upper ~ PAREN_CLOSE }
annotation_regex = { ANNOTATION_REGEX ~ PAREN_OPEN ~ quoted_string_literal ~ PAREN_CLOSE }
annotation_subkey = { ANNOTATION_SUBKEY ~ PAREN_OPEN ~ label ~ PAREN_CLOSE }
annotation_values = { ANNOTATION_VALUES ~ PAREN_OPEN ~ value_literal ~ ( COMMA ~ value_literal )* ~ PAREN_CLOSE }

// TYPEQL SYNTAX KEYWORDS ======================================================

reserved = { WITH | MATCH | FETCH | DEFINE | UNDEFINE | INSERT | PUT | DELETE
           | CHECK | FIRST
           | ENTITY | RELATION | ATTRIBUTE | ROLE
           | ASC | DESC
           | STRUCT | FUN | RETURN
           | ALIAS | SUB | OWNS | AS | PLAYS | RELATES
           | IID | ISA | LINKS | HAS
           | IS | OR | NOT | TRY | IN
           | BOOLEAN | LONG | DOUBLE | DECIMAL | DATETIME_TZ | DATETIME | DATE | DURATION | STRING
           | TRUE | FALSE
           }

unreserved = { ABS | CEIL | FLOOR | ROUND | LENGTH
             | COUNT | MAX | MIN | MEAN | MEDIAN | STD | SUM
             | VALUE | FILTER | SORT | LIMIT | OFFSET | GROUP | LIKE | CONTAINS
             }

// QUERY COMMAND KEYWORDS

WITH = @{ "with" ~ WB }
MATCH = @{ "match" ~ WB }
FETCH = @{ "fetch" ~ WB }
DEFINE = @{ "define" ~ WB }
UNDEFINE = @{ "undefine" ~ WB }
INSERT = @{ "insert" ~ WB }
PUT = @{ "put" ~ WB }
DELETE = @{ "delete" ~ WB }

CHECK = @{ "check" ~ WB }
FIRST = @{ "first" ~ WB }

// THING KIND KEYWORDS

ENTITY = @{ "entity" ~ WB }
ATTRIBUTE = @{ "attribute" ~ WB }
RELATION = @{ "relation" ~ WB }
ROLE = @{ "role" ~ WB }

// QUERY MODIFIER KEYWORDS

FILTER = @{ "filter" ~ WB }
LIMIT = @{ "limit" ~ WB }
OFFSET = @{ "offset" ~ WB }
SORT = @{ "sort" ~ WB }

ORDER = ${ ASC | DESC }
ASC = @{ "asc" ~ WB }
DESC = @{ "desc" ~ WB }

// FUNCTION KEYWORDS

FUN = @{ "fun" ~ WB }
RETURN = @{ "return" ~ WB }

// TYPE VARIABLE CONSTRAINT KEYWORDS

ALIAS = @{ "alias" ~ WB }
AS = @{ "as" ~ WB }
FROM = @{ "from" ~ WB }
LABEL = @{ "label" ~ WB }
OWNS = @{ "owns" ~ WB }
PLAYS = @{ "plays" ~ WB }
RELATES = @{ "relates" ~ WB }
SUB_ = ${ SUBX | SUB }
SUB = @{ "sub" ~ WB }
SUBX = @{ "sub!" ~ WB }

// TYPE ANNOTATIONS

annotation_kind = ${ ANNOTATION_ABSTRACT
                   | ANNOTATION_CARD
                   | ANNOTATION_CASCADE
                   | ANNOTATION_DISTINCT
                   | ANNOTATION_INDEPENDENT
                   | ANNOTATION_KEY
                   | ANNOTATION_RANGE
                   | ANNOTATION_REGEX
                   | ANNOTATION_SUBKEY
                   | ANNOTATION_UNIQUE
                   | ANNOTATION_VALUES
                   }

// unparametrized
ANNOTATION_ABSTRACT = @{ "@abstract" ~ WB }
ANNOTATION_CASCADE = @{ "@cascade" ~ WB }
ANNOTATION_DISTINCT = @{ "@distinct" ~ WB }
ANNOTATION_KEY = @{ "@key" ~ WB }
ANNOTATION_INDEPENDENT = @{ "@independent" ~ WB }
ANNOTATION_UNIQUE = @{ "@unique" ~ WB }

// parametrized
ANNOTATION_CARD = @{ "@card" ~ WB }
ANNOTATION_RANGE = @{ "@range" ~ WB }
ANNOTATION_REGEX = @{ "@regex" ~ WB }
ANNOTATION_SUBKEY = @{ "@subkey" ~ WB }
ANNOTATION_VALUES = @{ "@values" ~ WB }

annotation_card_lower = @{ integer_literal }
annotation_card_upper = @{ integer_literal | ASTERISK }

// THING VARIABLE CONSTRAINT KEYWORDS

IID = @{ "iid" ~ WB }
ISA_ = ${ ISAX | ISA }
ISA = @{ "isa" ~ WB }
ISAX = @{ "isa!" ~ WB }
LINKS = @{ "links" ~ WB }
HAS = @{ "has" ~ WB }
VALUE = @{ "value" ~ WB }
IS = @{ "is" ~ WB }

// PATTERN KEYWORDS

OR = @{ "or" ~ WB }
NOT = @{ "not" ~ WB }
TRY = @{ "try" ~ WB }

// COMPARATOR KEYWORDS

EQ = @{ "==" }
NEQ = @{ "!=" }
GT = @{ ">" }
GTE = @{ ">=" }
LT = @{ "<" }
LTE = @{ "<=" }
LIKE = @{ "like" ~ WB }
CONTAINS = @{ "contains" ~ WB }

// ASSIGNMENT AND EXPRESSION KEYWORDS

ASSIGN = @{ "=" }
IN = @{ "in" ~ WB }

PLUS = @{ "+" }     // unary plus, addition
MINUS = @{ "-" }    // unary negation, subtraction
SOLIDUS = @{ "/" }  // division
ASTERISK = @{ "*" } // multiplication, unbounded cardinality
CARET = @{ "^" }    // exponentiation
PERCENT = @{ "%" }  // modulo

// Incomplete list of function names usable in expressions. The 'expression_function_name' rule references all function names.
builtin_func_name = ${ ABS | CEIL | FLOOR | ROUND | LENGTH | MAX | MIN }
ABS = @{ "abs" ~ WB }
CEIL = @{ "ceil" ~ WB }
FLOOR = @{ "floor" ~ WB }
LENGTH = @{ "length" ~ WB }
ROUND = @{ "round" ~ WB }

// GROUP AND AGGREGATE QUERY KEYWORDS (also used by COMPUTE QUERY)

GROUP = @{ "group" ~ WB }
COUNT = @{ "count" ~ WB }
MAX = @{ "max" ~ WB }
MIN = @{ "min" ~ WB }
MEAN = @{ "mean" ~ WB }
MEDIAN = @{ "median" ~ WB }
STD = @{ "std" ~ WB }
SUM = @{ "sum" ~ WB }

// VALUE TYPE KEYWORDS

BOOLEAN = @{ "boolean" ~ WB }
LONG = @{ "long" ~ WB }
DOUBLE = @{ "double" ~ WB }
DECIMAL = @{ "decimal" ~ WB }

DATE = @{ "date" ~ WB }
DATETIME = @{ "datetime" ~ WB }
DATETIME_TZ = @{ "datetime-tz" ~ WB }
DURATION = @{ "duration" ~ WB }

STRING = @{ "string" ~ WB }
STRUCT = @{ "struct" ~ WB }

// LITERAL VALUE KEYWORDS
boolean_literal = ${ TRUE | FALSE } // order of lexer declaration matters
TRUE = @{ "true" ~ WB }
FALSE = @{ "false" ~ WB }

integer_literal = @{ ASCII_DIGIT+ ~ WB }
decimal_literal = @{ ASCII_DIGIT+ ~ "." ~ ASCII_DIGIT+ ~ ( ^"e" ~ sign? ~ integer_literal )? ~ WB }
numeric_literal = @{ integer_literal | decimal_literal }

date_literal = ${ date_fragment ~ WB }
datetime_literal = ${ date_fragment ~ "T" ~ time ~ WB }
datetime_tz_literal = ${ date_fragment ~ "T" ~ time ~ ( " " ~ iana_timezone | iso8601_timezone_offset ) ~ WB }

duration_literal = ${ "P" ~ ( duration_weeks | duration_date ~ ( "T" ~ duration_time )? ) ~ WB}

quoted_string_literal = @{ "\"" ~ ( !"\"" ~ !"\\" ~ ANY | escape_seq )* ~ "\""
                         | "'" ~ ( !"'" ~ !"\\" ~ ANY | escape_seq )* ~ "'" }

// PUNCTUATION =================================================================

PAREN_OPEN = _{ "(" }
PAREN_CLOSE = _{ ")" }
SQ_BRACKET_OPEN = _{ "[" }
SQ_BRACKET_CLOSE = _{ "]" }
CURLY_OPEN = _{ "{" }
CURLY_CLOSE = _{ "}" }
COMMA = _{ "," }
SEMICOLON = _{ ";" }
COLON = _{ ":" }
QUESTION = _{ "?" }
ARROW = _{ "->" }

// FRAGMENTS OF KEYWORDS =======================================================

IDENTIFIER_CHAR = @{ ASCII_ALPHA
                   // | '\u{00C0}'..'\u{00D6}'
                   // | '\u{00D8}'..'\u{00F6}'
                   // | '\u{00F8}'..'\u{02FF}'
                   // | '\u{0370}'..'\u{037D}'
                   // | '\u{037F}'..'\u{1FFF}'
                   // | '\u{200C}'..'\u{200D}'
                   // | '\u{2070}'..'\u{218F}'
                   // | '\u{2C00}'..'\u{2FEF}'
                   // | '\u{3001}'..'\u{D7FF}'
                   // | '\u{F900}'..'\u{FDCF}'
                   // | '\u{FDF0}'..'\u{FFFD}'
                   }
IDENTIFIER_CONNECTOR = @{ "_"
                        | "-"
                        // | "\u{00B7}"
                        // | '\u{0300}'..'\u{036F}'
                        // | '\u{203F}'..'\u{2040}'
                        }

IDENTIFIER_LABEL_H = @{ IDENTIFIER_CHAR }
IDENTIFIER_LABEL_T = @{ IDENTIFIER_LABEL_H | ASCII_DIGIT | IDENTIFIER_CONNECTOR }

IDENTIFIER_VAR_H = @{ IDENTIFIER_CHAR | ASCII_DIGIT }
IDENTIFIER_VAR_T = @{ IDENTIFIER_VAR_H | IDENTIFIER_CONNECTOR }

date_fragment = ${ year ~ "-" ~ month ~ "-" ~ day }
month = @{ "0" ~ ( '1'..'9' ) | "10" | "11" | "12" }
day = @{ ( '0'..'3' ) ~ ASCII_DIGIT }
year = @{ ASCII_DIGIT{4} | ( "+" | "-" ) ~ ASCII_DIGIT+ }
time = ${ hour ~ COLON ~ minute ~ ( COLON ~ second ~ ( "." ~ second_fraction )? )? }
hour = @{ ( '0'..'2' ) ~ ASCII_DIGIT }
minute = @{ ( '0'..'5' ) ~ ASCII_DIGIT }
second = @{ ( '0'..'6' ) ~ ASCII_DIGIT }
second_fraction = @{ ASCII_DIGIT{1,9} } // between 1 and 9 digits

iso8601_timezone_offset = @{ "Z" | sign ~ hour ~ ( COLON? ~ minute )? } // "Z", "±HH", "±HHMM", "±HH:MM"

iana_timezone = @{ iana_timezone_single ~ ( "/" ~ iana_timezone_single ){0,2} ~ WB }
iana_timezone_single = @{ 'A'..'Z' ~ ( ASCII_ALPHANUMERIC | "_" | "-" | "+" )+ }

duration_date = ${ duration_years ~ duration_months? ~ duration_days?
                 | duration_months ~ duration_days?
                 | duration_days
                 }
duration_years = ${ integer_literal ~ "Y" }
duration_months = ${ integer_literal ~ "M" }
duration_weeks = ${ integer_literal ~ "W" }
duration_days = ${ integer_literal ~ "D" }

duration_time = ${ duration_hours ~ duration_minutes? ~ duration_seconds?
                 | duration_minutes ~ duration_seconds?
                 | duration_seconds
                 }
duration_hours = ${ integer_literal ~ "H" }
duration_minutes = ${ integer_literal ~ "M" }
duration_seconds = ${ numeric_literal ~ "S" }

escape_seq = @{ "\\" ~ ANY }

WB = _{ &( PUNCTUATION | WHITESPACE | COMMENT | EOI ) } // Word boundary

COMMENT = _{ "#" ~ ( !NEWLINE ~ ANY )* ~ ( NEWLINE | EOI ) }
WHITESPACE = _{ " " | "\t" | "\r" | "\n" }
